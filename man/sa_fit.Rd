% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simulated_annealing.R
\name{sa_fit}
\alias{sa_fit}
\title{Simulated Annealing Optimization for Generalized Non-Linear Models}
\usage{
sa_fit(
  y,
  X,
  Z,
  family,
  f_mu,
  J_mu,
  H_mu,
  f_phi,
  J_phi,
  H_phi,
  beta_start,
  lower_mu,
  upper_mu,
  gamma_start,
  lower_phi,
  upper_phi,
  fixed_params = NULL,
  mult,
  nsim,
  sa_control_params = sa_control(),
  expected = TRUE,
  verbose = TRUE
)
}
\arguments{
\item{y}{Numeric vector of response values.}

\item{X}{Numeric design matrix for the mean component.}

\item{Z}{Numeric design matrix for the dispersion component.}

\item{family}{An object of class \code{\link{family_gnlmsa}} that defines the distribution, link functions, and relevant derivatives.}

\item{f_mu}{Predictor function for the mean component.}

\item{J_mu}{(Optional) Jacobian of \code{f_mu}. Should return an \eqn{n \times k} matrix.}

\item{H_mu}{(Optional) Hessian of \code{f_mu}. Should return a list of \eqn{n} Hessian matrices.}

\item{f_phi}{Predictor function for the dispersion component.}

\item{J_phi}{(Optional) Jacobian of \code{f_phi}.}

\item{H_phi}{(Optional) Hessian of \code{f_phi}.}

\item{beta_start}{Initial values for parameters of the mean component.}

\item{lower_mu}{Numeric vector defining lower bounds for the mean parameters.}

\item{upper_mu}{Numeric vector defining upper bounds for the mean parameters.}

\item{gamma_start}{Initial values for parameters of the dispersion component.}

\item{lower_phi}{Numeric vector defining lower bounds for the dispersion parameters.}

\item{upper_phi}{Numeric vector defining upper bounds for the dispersion parameters.}

\item{fixed_params}{A list containing two numeric vectors of the same length:
\itemize{
\item The first vector specifies the indices of the parameters to be fixed.
\item The second vector provides the corresponding fixed values for those parameters.
}}

\item{mult}{Multipliers for the proposal variance in the SA algorithm.}

\item{nsim}{Number of independent SA chains to run (for potential parallelization; currently only 1 is supported).}

\item{sa_control_params}{A list of control parameters for the SA routine, as returned by \code{\link[=sa_control]{sa_control()}}.}

\item{expected}{Logical; if \code{TRUE}, the expected (Fisher) information matrix is used to update the proposal variance.}

\item{verbose}{Logical; if \code{TRUE}, prints algorithm progress every 100 iterations.}
}
\value{
A list of class \code{"sa"} with elements:
\describe{
\item{par}{Estimated parameter vector (concatenated \code{beta} and \code{gamma}).}
\item{beta, gamma}{Estimated parameters for the mean and dispersion components, respectively.}
\item{loglik}{Final log-likelihood value.}
\item{eta, mu}{Nonlinear predictor and fitted values for the mean component.}
\item{vi, phi}{Nonlinear predictor and fitted values for the dispersion component.}
\item{iterations}{Total number of iterations performed.}
\item{history}{Optional. Vector of log-likelihood values at each iteration, if \code{save_history = TRUE}.}
\item{control}{Control parameters used during optimization.}
}
}
\description{
Performs parameter estimation for Generalized Non-Linear Models (GNLMs) using a Simulated Annealing (SA) algorithm.
This global optimization technique searches for a maximum of the log-likelihood function by exploring the
parameter space in a probabilistic way, before passing control to a local optimizer.
}
\details{
The SA algorithm operates on a transformed parameter space: all constrained parameters are mapped
to \eqn{\mathbb{R}} via bijective transformations to ensure feasibility.

At intervals determined by \code{sa_control_params$compute_v}, the algorithm estimates a local variance-covariance
matrix from the (expected or observed) Hessian of the log-likelihood and uses it to adapt the proposal distribution.

If no improvement is detected after a certain number of iterations (\code{restart_if_stuck}), the algorithm
restarts from the best parameter configuration found so far. At the end of the annealing schedule,
the solution can be passed to a local optimizer (e.g., Newton-Raphson).
}
\examples{
\dontrun{
# create family object
fam_gamma <- gnlmsa_Gamma(link_mu = "identity", link_phi = "log")

# create non linear function for mean
cd <- cobb_douglas()
f_mu <- cd$f
J_mu <- cd$J
H_mu <- cd$H

# create non linear function for dispersion
lin <- Linear()
f_phi <- lin$f
J_phi <- lin$J
H_phi <- lin$H

# sample size
n <- 100

# covariates for the mean component
X <- cbind(rgamma(n, 1000, 10), rgamma(n, 2000, 5))

# covariates for the variance component
Z <- cbind(1, X)

# parameters for mean component
beta <- c(3, .4, .4)
eta <- f_mu(X, beta)
mu <- fam_gamma$linkinv_mu(eta)

# parameters for dispersion component
gamma <- c(0.5, .01, .05)
vi <- f_phi(Z, gamma)
phi <- fam_gamma$linkinv_phi(vi)

# simulate response
y <- rgamma(n, phi, phi/mu)
try(pairs(cbind(X, y)))
summary(cbind(X, y))

# arguments
y = y # y
X = X # X
Z = Z # Z
family = gnlmsa_Gamma(link_mu = "identity", link_phi = "log") # family
f_mu = cobb_douglas()$f
J_mu = cobb_douglas()$J
H_mu = cobb_douglas()$H
f_phi = Linear()$f
J_phi = Linear()$J
H_phi = Linear()$H
beta_start = c(1, .9, .8)
lower_mu = c(0, 0, 0) # lower_mu
upper_mu = c(Inf, Inf, Inf) # upper_mu
gamma_start = c(1, 0, 0)
lower_phi = c(-Inf, -Inf, -Inf) # lower_phi
upper_phi = c(Inf, Inf, Inf) # upper_phi
mult = 1 # mult
nsim = 1 # nsim (number of SA simulations to run in parallel)
sa_control_list = sa_control(iterations = 1000,
                             initial_temperature = 100,
                             final_temperature = .01,
                             restart_if_stuck = floor(1000 * 0.01)) # sa_control
expected = TRUE
verbose = TRUE


fit1 <- sa_fit(y = y, X = X, Z = Z, family = family,
               f_mu = f_mu, J_mu = J_mu, H_mu = H_mu,
               f_phi = f_phi, J_phi = J_phi, H_phi = H_phi,
               beta_start = beta_start, lower_mu = lower_mu, upper_mu = upper_mu,
               gamma_start = gamma_start, lower_phi = lower_phi, upper_phi = upper_phi,
               mult = mult, nsim = nsim, sa_control_params = sa_control_list,
               expected = expected, verbose = verbose)

fit1
}

}
\seealso{
\code{\link[=sa_control]{sa_control()}} for creating control parameters
}
