% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simulated_annealing.R
\name{sa_fit}
\alias{sa_fit}
\title{Simulated Annealing for Generalized Non-Linear Models}
\usage{
sa_fit(
  y,
  X,
  Z,
  family,
  f_mu,
  J_mu,
  H_mu,
  f_phi,
  J_phi,
  H_phi,
  beta_start,
  lower_mu,
  upper_mu,
  gamma_start,
  lower_phi,
  upper_phi,
  mult,
  nsim,
  sa_control = sa_control(),
  expected = TRUE,
  verbose = TRUE
)
}
\arguments{
\item{y}{numerical vector of response values.}

\item{X}{design matrix for the mean model.}

\item{Z}{design matrix for the dispersion model.}

\item{family}{a \code{\link{family_gnlmsa}} object.}

\item{f_mu}{predictor function for the mean component.}

\item{J_mu}{(optional) Jacobian of \code{f_mu} with respect to the parameters.}

\item{H_mu}{(optional) Hessian of \code{f_mu} with respect to the parameters.}

\item{f_phi}{predictor function for the dispersion component.}

\item{J_phi}{(optional) Jacobian of \code{f_phi} with respect to the parameters.}

\item{H_phi}{(optional) Hessian of \code{f_phi} with respect to the parameters.}

\item{beta_start}{initial values for the parameters of the mean component.}

\item{lower_mu}{lower bounds for the parameters of the mean component.}

\item{upper_mu}{upper bounds for the parameters of the mean component.}

\item{gamma_start}{initial values for the parameters of the dispersion component.}

\item{lower_phi}{lower bounds for the parameters of the dispersion component.}

\item{upper_phi}{upper bounds for the parameters of the dispersion component.}

\item{mult}{numerical vector multipliers of errors in Simulated Annealing algorithm.}

\item{nsim}{number of Simulated Annealing simulations to perform (possibly in parallel).}

\item{sa_control}{list of control parameters for Simulated Annealing algorithm, created with \code{sa_control()}}

\item{expected}{logical indicating whether to use expected (\code{expected = TRUE}, default) or observed (\code{expected = FALSE}) hessian.}

\item{verbose}{logical indicating whether to print progress information.}
}
\value{
A list with class "sa" containing:
\item{par}{Estimated parameters}
\item{beta}{Estimated parameters for the mean component}
\item{gamma}{Estimated parameters for the dispersion component}
\item{loglik}{Maximum log-likelihood value found}
\item{eta}{Predictor for the mean component}
\item{mu}{Fitted mean values}
\item{vi}{Predictor for the dispersion component}
\item{phi}{Fitted dispersion values}
\item{iterations}{Number of iterations performed}
\item{history}{Vector of log-likelihood values at each iteration (if \code{save_history = TRUE})}
\item{control}{Control parameters used for the algorithm.}
}
\description{
Optimizes parameters of a generalized linear model with separate functions for mean and dispersion
using simulated annealing. The algorithm explores the parameter space to find a candidate maximum point
of the log-likelihood function.
}
\details{
The function implements a Simulated Annealing algorithm for finding the values of the parameters that possibly maximize the
log-likelihood of a Generalized Non-Linear model. Those values can be used as starting value in order to converge to a possibly global maximum via other optimizations algorithms.

The algorithm maps between constrained and unconstrained parameter spaces to respect the bounds
specified by \code{lower_mu}, \code{upper_mu}, \code{lower_phi}, and \code{upper_phi}.

At regular intervals (controlled by \code{sa_control$compute_v}), the algorithm recomputes the
variance-covariance matrix used for the proposal distribution based on the Hessian of the
log-likelihood.
}
\examples{
\dontrun{
# create family object
fam_gamma <- gnlmsa_Gamma(link_mu = "identity", link_phi = "log")

# create non linear function for mean
cd <- cobb_douglas()
f_mu <- cd$f
J_mu <- cd$J
H_mu <- cd$H

# create non linear function for dispersion
lin <- Linear()
f_phi <- lin$f
J_phi <- lin$J
H_phi <- lin$H

# sample size
n <- 100

# covariates for the mean component
X <- cbind(rgamma(n, 1000, 10), rgamma(n, 2000, 5))

# covariates for the variance component
Z <- cbind(1, X)

# parameters for mean component
beta <- c(3, .4, .4)
eta <- f_mu(X, beta)
mu <- fam_gamma$linkinv_mu(eta)

# parameters for dispersion component
gamma <- c(0.5, .01, .05)
vi <- f_phi(Z, gamma)
phi <- fam_gamma$linkinv_phi(vi)

# simulate response
y <- rgamma(n, phi, phi/mu)
try(pairs(cbind(X, y)))
summary(cbind(X, y))

# arguments
y = y # y
X = X # X
Z = Z # Z
family = gnlmsa_Gamma(link_mu = "identity", link_phi = "log") # family
f_mu = cobb_douglas()$f
J_mu = cobb_douglas()$J
H_mu = cobb_douglas()$H
f_phi = Linear()$f
J_phi = Linear()$J
H_phi = Linear()$H
beta_start = c(1, .9, .8)
lower_mu = c(0, 0, 0) # lower_mu
upper_mu = c(Inf, Inf, Inf) # upper_mu
gamma_start = c(1, 0, 0)
lower_phi = c(-Inf, -Inf, -Inf) # lower_phi
upper_phi = c(Inf, Inf, Inf) # upper_phi
mult = 1 # mult
nsim = 1 # nsim (number of SA simulations to run in parallel)
sa_control_list = sa_control(iterations = 1000,
                             initial_temperature = 100,
                             final_temperature = .01,
                             restart_if_stuck = floor(1000 * 0.01)) # sa_control
expected = TRUE
verbose = TRUE


fit1 <- sa_fit(y = y, X = X, Z = Z, family = family,
               f_mu = f_mu, J_mu = J_mu, H_mu = H_mu,
               f_phi = f_phi, J_phi = J_phi, H_phi = H_phi,
               beta_start = beta_start, lower_mu = lower_mu, upper_mu = upper_mu,
               gamma_start = gamma_start, lower_phi = lower_phi, upper_phi = upper_phi,
               mult = mult, nsim = nsim, sa_control = sa_control_list,
               expected = expected, verbose = verbose)

fit1
}

}
\seealso{
\code{\link[=sa_control]{sa_control()}} for creating control parameters
}
