% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gnlmsa.R
\name{gnlmsa}
\alias{gnlmsa}
\title{Fit a Generalized Non-Linear Model with Mean and Dispersion Components}
\usage{
gnlmsa(
  y,
  X,
  Z,
  family,
  f_mu,
  J_mu,
  H_mu,
  f_phi,
  J_phi,
  H_phi,
  beta_start,
  lower_mu,
  upper_mu,
  gamma_start,
  lower_phi,
  upper_phi,
  mult,
  nsim,
  sa_control = sa_control(),
  maxit = 100,
  tol = 1e-05,
  expected = TRUE,
  verbose = TRUE,
  beta_names,
  gamma_names
)
}
\arguments{
\item{y}{Numeric vector of response values.}

\item{X}{Design matrix for the mean component.}

\item{Z}{Design matrix for the dispersion component.}

\item{family}{A \code{\link{family_gnlmsa}} object specifying distributional assumptions and required derivatives.}

\item{f_mu}{Function for the mean component nonlinear predictor.}

\item{J_mu}{(Optional) Jacobian of \code{f_mu}.}

\item{H_mu}{(Optional) Hessian of \code{f_mu}.}

\item{f_phi}{Function for the dispersion component nonlinear predictor.}

\item{J_phi}{(Optional) Jacobian of \code{f_phi}.}

\item{H_phi}{(Optional) Hessian of \code{f_phi}.}

\item{beta_start}{Initial values for the parameters of the mean component.}

\item{lower_mu}{Numeric vector defining lower bounds for the mean parameters.}

\item{upper_mu}{Numeric vector defining upper bounds for the mean parameters.}

\item{gamma_start}{Initial values for the parameters of the dispersion component.}

\item{lower_phi}{Numeric vector defining lower bounds for the dispersion parameters.}

\item{upper_phi}{Numeric vector defining upper bounds for the dispersion parameters.}

\item{mult}{Proposal scaling factor for the Simulated Annealing algorithm.}

\item{nsim}{Number of independent Simulated Annealing simulations (currently only \code{1} is supported).}

\item{sa_control}{A list of Simulated Annealing options created via \code{\link[=sa_control]{sa_control()}}.}

\item{maxit}{Maximum number of Newton–Raphson iterations.}

\item{tol}{Tolerance for convergence in Newton–Raphson.}

\item{expected}{Logical; use the expected (\code{TRUE}) or the observed (\code{FALSE}) Hessian.}

\item{verbose}{Logical; print progress during Simulated Annealing.}

\item{beta_names}{(Optional) Names of the parameters in the mean component.}

\item{gamma_names}{(Optional) Names of the parameters in the dispersion component.}
}
\value{
A list of class \code{"gnlmsa"} containing:
\describe{
\item{coef}{Named vector of estimated parameters (concatenation of \code{beta} and \code{gamma}).}
\item{beta, gamma}{Estimated coefficients for mean and dispersion components.}
\item{loglik}{Log-likelihood of the final fitted model.}
\item{eta, mu}{Predictor and fitted values for the mean component.}
\item{vi, phi}{Predictor and fitted values for the dispersion component.}
\item{nsim, mult}{Settings used for Simulated Annealing.}
\item{nobs, df, df.residuals}{Sample size and degrees of freedom.}
\item{npar_mu}{Number of parameters for the mean component.}
\item{nr_failed}{Logical; \code{TRUE} if the Newton–Raphson step failed.}
\item{nr_better}{Logical; \code{TRUE} if Newton–Raphson log-likelihood was better than Simulated Annealing.}
\item{mean_model, dispersion_model}{List of functions used to specify model components.}
\item{map_functions}{List of mapping functions used to transform bounded to unbounded parameters.}
\item{lower, upper}{Parameter bounds.}
\item{family}{The \code{family_gnlmsa} object used.}
\item{X, Z, y}{Original data matrices and response vector.}
}
}
\description{
The fitting procedure consists of two stages:
\enumerate{
\item Simulated Annealing is used to explore the parameter space and identify a good candidate solution.
\item Newton–Raphson is then used to refine this candidate. If the local optimization fails, or
the Simulated Annealing solution yields a higher log-likelihood, the SA result is retained.
}
}
\details{
Fits a Generalized Non-Linear Model (GNLM) by combining global optimization via Simulated Annealing
and local refinement via Newton–Raphson. The model includes both a mean component and a dispersion
component, each of which can be specified using user-defined nonlinear predictors.
}
\examples{
\dontrun{
y <- productivity$Y
X <- as.matrix(productivity[, -1])
Z <- cbind(1, prcomp(scale(X))$x[, 1])
family <- gnlmsa_Gamma("identity")
f_mu <- cobb_douglas()$f
J_mu <- cobb_douglas()$J
H_mu <- cobb_douglas()$H
f_phi <- Linear()$f
J_phi <- Linear()$J
H_phi <- Linear()$H
beta_start <- c(10, .5, .5)
lower_mu <- rep(0, 3)
upper_mu <- rep(Inf, 3)
gamma_start <- c(log(var(y)), 0)
lower_phi <- rep(-Inf, 2)
upper_phi <- rep(Inf, 2)
mult <- 1
nsim <- 1
sa_control <- sa_control(10000)
maxit <- 100
tol <- 1e-05
expected <- TRUE
verbose <- TRUE
beta_names <- c("a", "alpha", "beta")
gnlmsa(y, X, Z, family,
       f_mu, J_mu, H_mu,
       f_phi, J_phi, H_phi,
       beta_start, lower_mu, upper_mu,
       gamma_start, lower_phi, upper_phi,
       mult, nsim, sa_control = sa_control(),
       maxit = 100, tol = 1e-05,
       expected = TRUE, verbose = TRUE,
       beta_names)
}
}
