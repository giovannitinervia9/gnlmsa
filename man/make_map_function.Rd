% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/helper_functions.R
\name{make_map_function}
\alias{make_map_function}
\title{Create mapping functions between constrained parameter spaces and the real line}
\usage{
make_map_function(lower, upper)
}
\arguments{
\item{lower}{A numeric vector containing the lower bounds for each parameter.
Use \code{-Inf} for unbounded below parameters.}

\item{upper}{A numeric vector containing the upper bounds for each parameter.
Use \code{Inf} for unbounded above parameters.}
}
\value{
A list containing six functions: \code{map}, \code{invert}, \code{map_jacobian},
\code{map_hessian}, \code{invert_jacobian}, \code{invert_hessian}.
}
\description{
Returns a set of transformation functions that map parameters from various constrained spaces
to the real line and vice versa, along with their first and second derivatives.
}
\details{
The function automatically selects the appropriate transformation for each parameter based on its bounds:
\itemize{
\item For parameters bounded both below and above \code{(lower[i], upper[i])}, \code{\link[=map_interval]{map_interval()}} is used.
\item For parameters bounded only below \code{(lower[i], Inf)}, \code{\link[=map_positive]{map_positive()}} is used.
\item For parameters bounded only above \code{(-Inf, upper[i])}, \code{\link[=map_negative]{map_negative()}} is used.
\item For completely unbounded parameters \code{(-Inf, Inf)}, the identity function is used.
}

The returned list contains six functions:
\describe{
\item{map(par)}{Maps parameters from the constrained space to the real line.}
\item{invert(par)}{Maps parameters from the real line back to the constrained space.}
\item{map_jacobian(par)}{Returns the first derivative (Jacobian) of the forward transformation.}
\item{map_hessian(par)}{Returns the second derivative (Hessian) of the forward transformation.}
\item{invert_jacobian(par)}{Returns the first derivative (Jacobian) of the inverse transformation.}
\item{invert_hessian(par)}{Returns the second derivative (Hessian) of the inverse transformation.}
}
Each function expects a numeric vector \code{par} of the same length as \code{lower} and \code{upper}.
}
\examples{
# Define constraints for parameters
lower <- c(-Inf, 0, -1)
upper <- c(Inf, Inf, 1)

# Create mapping functions
map_functions <- make_map_function(lower, upper)

# Extract the individual functions
map <- map_functions$map
invert <- map_functions$invert
map_jacobian <- map_functions$map_jacobian
map_hessian <- map_functions$map_hessian
invert_jacobian <- map_functions$invert_jacobian
invert_hessian <- map_functions$invert_hessian

# Define parameter values in the constrained space
x <- c(0, 3, 0.2)

# Map to unconstrained space
y <- map(x)

# Invert mapping back to constrained space
x_recovered <- invert(y)

# Verify that the mapping is bijective
all.equal(x, x_recovered)

# Compute derivatives
j_map <- map_jacobian(x)
h_map <- map_hessian(x)
j_invert <- invert_jacobian(y)
h_invert <- invert_hessian(y)
}
